<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aikea Exercise Renderer - LangSmith</title>

  <!-- KaTeX CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" crossorigin="anonymous">

  <!-- KaTeX JS -->
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js" crossorigin="anonymous"></script>

  <style>
    /* Reset and base styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      /* Aikea color system */
      --accent-pink: #FF36AB;
      --info-400: #204FD0;
      --purple-800: #35105D;
      --primary-text-high: #CC4E00;
      --success-base: #22C55E;
      --success-light: #DCFCE7;
      --error-base: #EF4444;
      --error-light: #FEE2E2;
      --neutral-100: #E8E7E6;
      --neutral-300: #D1D1D1;
      --tertiary-50: #FCFBFC;
      --blue-50: #EFF6FF;
      --border-color: #204FD0;
      --warning-base: #F59E0B;
      --warning-light: #FEF3C7;

      /* Typography */
      --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    }

    body {
      font-family: var(--font-family);
      background-color: #FAFAFA;
      color: #1F2937;
      line-height: 1.5;
      padding: 16px;
      min-height: 100vh;
    }

    /* Container for all exercises */
    .exercises-container {
      display: flex;
      flex-direction: column;
      gap: 24px;
      max-width: 800px;
      margin: 0 auto;
    }

    /* Individual exercise card */
    .exercise {
      background: white;
      border-radius: 16px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      padding: 24px;
      border: 1px solid var(--neutral-100);
    }

    /* Exercise header with type badge */
    .exercise-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--neutral-100);
    }

    .exercise-type-badge {
      background: var(--blue-50);
      color: var(--info-400);
      font-size: 11px;
      font-weight: 600;
      padding: 4px 10px;
      border-radius: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .exercise-type-badge.multi-select {
      background: #F3E8FF;
      color: #7C3AED;
    }

    .exercise-type-badge.match {
      background: #FEF3C7;
      color: #D97706;
    }

    .exercise-type-badge.true-false {
      background: #ECFDF5;
      color: #059669;
    }

    .exercise-type-badge.arrange {
      background: #FFF7ED;
      color: #EA580C;
    }

    .exercise-type-badge.type {
      background: #F0F9FF;
      color: #0284C7;
    }

    .exercise-type-badge.grouping {
      background: #FDF2F8;
      color: #DB2777;
    }

    .exercise-type-badge.table {
      background: #F5F3FF;
      color: #6D28D9;
    }

    .exercise-number {
      color: #6B7280;
      font-size: 14px;
      font-weight: 500;
    }

    /* Card sections (for [card] tags) */
    .card-section {
      background: var(--tertiary-50);
      border: 1.5px solid var(--neutral-100);
      border-radius: 12px;
      padding: 20px;
      margin: 16px 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .card-section.align-center {
      align-items: center;
    }

    .card-section.align-start {
      align-items: flex-start;
    }

    .card-section.align-end {
      align-items: flex-end;
    }

    .card-section.justify-center {
      justify-content: center;
    }

    /* Exercise content */
    .exercise-content {
      font-size: 18px;
      color: #1F2937;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    /* Choices section */
    .choices-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .choices-container.layout-row {
      flex-direction: row;
      flex-wrap: wrap;
    }

    .choices-container.layout-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
    }

    /* Individual choice button */
    .choice-button {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 20px;
      background: white;
      border: 1.5px solid var(--neutral-300);
      border-radius: 12px;
      cursor: default;
      transition: all 0.15s ease;
      min-height: 54px;
    }

    .choice-button.correct {
      background: var(--success-light);
      border-color: var(--success-base);
    }

    .choice-button .choice-indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      font-size: 12px;
      font-weight: 600;
      flex-shrink: 0;
    }

    .choice-button.correct .choice-indicator {
      background: var(--success-base);
      color: white;
    }

    .choice-button:not(.correct) .choice-indicator {
      background: var(--neutral-100);
      color: #6B7280;
    }

    /* Checkbox style for multi-select */
    .choice-button .choice-checkbox {
      width: 20px;
      height: 20px;
      border: 2px solid var(--neutral-300);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .choice-button.correct .choice-checkbox {
      background: var(--success-base);
      border-color: var(--success-base);
      color: white;
    }

    .choice-content {
      flex: 1;
      font-size: 16px;
    }

    .correct-icon {
      color: var(--success-base);
      font-size: 18px;
      margin-left: auto;
    }

    /* Match exercise styles */
    .match-container {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .match-pair {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 12px 16px;
      background: var(--success-light);
      border: 1.5px solid var(--success-base);
      border-radius: 12px;
    }

    .match-item {
      flex: 1;
      padding: 10px 16px;
      background: white;
      border-radius: 8px;
      text-align: center;
      font-size: 16px;
    }

    .match-arrow {
      color: var(--success-base);
      font-size: 20px;
      font-weight: bold;
    }

    /* Arrange exercise styles */
    .arrange-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .arrange-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 20px;
      background: var(--success-light);
      border: 1.5px solid var(--success-base);
      border-radius: 12px;
    }

    .arrange-number {
      width: 28px;
      height: 28px;
      background: var(--success-base);
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 14px;
      flex-shrink: 0;
    }

    .arrange-content {
      flex: 1;
      font-size: 16px;
    }

    /* Complete Arrange specific styles */
    .arrange-item.complete-arrange {
      background: var(--blue-50);
      border-color: var(--info-400);
    }

    .arrange-blank-indicator {
      width: 28px;
      height: 28px;
      background: var(--info-400);
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 14px;
      flex-shrink: 0;
    }

    /* Type/Input exercise styles */
    .input-container {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .input-field {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .input-label {
      font-size: 14px;
      color: #6B7280;
      min-width: 80px;
    }

    .input-answer {
      flex: 1;
      padding: 12px 16px;
      background: var(--success-light);
      border: 1.5px solid var(--success-base);
      border-radius: 8px;
      font-size: 16px;
      font-family: 'SF Mono', 'Monaco', monospace;
    }

    /* Grouping exercise styles */
    .grouping-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .grouping-column {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .grouping-header {
      font-weight: 600;
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #6B7280;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--neutral-100);
      margin-bottom: 8px;
    }

    .grouping-header.left {
      color: var(--info-400);
      border-color: var(--info-400);
    }

    .grouping-header.right {
      color: var(--accent-pink);
      border-color: var(--accent-pink);
    }

    .grouping-item {
      padding: 12px 16px;
      background: white;
      border: 1.5px solid var(--neutral-300);
      border-radius: 8px;
      font-size: 15px;
    }

    .grouping-item.left {
      border-color: var(--info-400);
      background: var(--blue-50);
    }

    .grouping-item.right {
      border-color: var(--accent-pink);
      background: #FDF2F8;
    }

    /* Table exercise styles */
    .table-container {
      overflow-x: auto;
    }

    .exercise-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 15px;
    }

    .exercise-table th,
    .exercise-table td {
      padding: 12px 16px;
      border: 1px solid var(--neutral-100);
      text-align: center;
    }

    .exercise-table th {
      background: var(--tertiary-50);
      font-weight: 600;
      color: #374151;
    }

    .exercise-table td.answer {
      background: var(--success-light);
      font-family: 'SF Mono', 'Monaco', monospace;
    }

    /* Math rendering */
    .katex {
      font-size: 1.1em;
    }

    .katex-display {
      margin: 12px 0;
    }

    /* Color styling for text (matching Outex color map) */
    .color-accent-pink {
      color: var(--accent-pink);
    }

    .color-info-400 {
      color: var(--info-400);
    }

    .color-purple-800 {
      color: var(--purple-800);
    }

    .color-primary-text-high {
      color: var(--primary-text-high);
    }

    /* Debug section */
    .debug-section {
      margin-top: 32px;
      border-top: 1px solid var(--neutral-100);
      padding-top: 16px;
    }

    .debug-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      background: none;
      border: 1px solid var(--neutral-300);
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      color: #6B7280;
      transition: all 0.15s ease;
    }

    .debug-toggle:hover {
      background: var(--tertiary-50);
      border-color: var(--info-400);
      color: var(--info-400);
    }

    .debug-toggle .arrow {
      transition: transform 0.2s ease;
    }

    .debug-toggle.expanded .arrow {
      transform: rotate(90deg);
    }

    .debug-content {
      display: none;
      margin-top: 12px;
      background: #1F2937;
      color: #E5E7EB;
      padding: 16px;
      border-radius: 8px;
      font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
      font-size: 12px;
      overflow-x: auto;
      max-height: 400px;
      overflow-y: auto;
    }

    .debug-content.visible {
      display: block;
    }

    .debug-content pre {
      white-space: pre-wrap;
      word-break: break-word;
    }

    /* Loading and error states */
    .loading-state {
      text-align: center;
      padding: 48px;
      color: #6B7280;
    }

    .loading-state .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--neutral-100);
      border-top-color: var(--info-400);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .error-state {
      background: var(--error-light);
      border: 1px solid var(--error-base);
      border-radius: 12px;
      padding: 20px;
      color: #991B1B;
    }

    .error-state h3 {
      font-size: 16px;
      margin-bottom: 8px;
    }

    .empty-state {
      text-align: center;
      padding: 48px;
      color: #6B7280;
      background: var(--tertiary-50);
      border-radius: 12px;
      border: 1px dashed var(--neutral-300);
    }

    .empty-state h3 {
      font-size: 18px;
      margin-bottom: 8px;
      color: #374151;
    }

    /* Metadata section */
    .metadata-section {
      background: var(--blue-50);
      border: 1px solid var(--info-400);
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 20px;
      font-size: 13px;
    }

    .metadata-section h4 {
      color: var(--info-400);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .metadata-item {
      display: flex;
      gap: 8px;
      margin-bottom: 4px;
    }

    .metadata-label {
      color: #6B7280;
      font-weight: 500;
    }

    .metadata-value {
      color: #1F2937;
    }

    /* Data type indicator */
    .data-type-indicator {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      margin-bottom: 16px;
    }

    .data-type-indicator.output {
      background: #DBEAFE;
      color: #1E40AF;
    }

    .data-type-indicator.reference {
      background: #FEF3C7;
      color: #92400E;
    }

    /* Blank/fill-in styling */
    .blank-answer {
      display: inline-block;
      padding: 2px 12px;
      background: var(--success-light);
      border: 1px solid var(--success-base);
      border-radius: 4px;
      font-family: 'SF Mono', 'Monaco', monospace;
      margin: 0 4px;
    }
  </style>
</head>
<body>
  <div id="app">
    <div class="loading-state">
      <div class="spinner"></div>
      <p>Waiting for exercise data...</p>
      <p style="font-size: 12px; margin-top: 8px; color: #9CA3AF;">Listening for postMessage events from LangSmith</p>
      <button onclick="window.location.href='?demo=true'" style="margin-top: 16px; padding: 8px 16px; background: var(--info-400); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 13px;">Load Demo Data</button>
    </div>
  </div>

  <script>
    // Global state
    let currentData = null;
    let debugVisible = false;

    // Exercise type constants
    const EXERCISE_TYPES = {
      MULTIPLE_CHOICE: 'MULTIPLE_CHOICE',
      MULTI_SELECT: 'MULTI_SELECT',
      TRUE_OR_FALSE: 'TRUE_OR_FALSE',
      MATCH: 'MATCH',
      MATCH_WITH_IMAGE: 'MATCH_WITH_IMAGE',
      ARRANGE: 'ARRANGE',
      COMPLETE_ARRANGE: 'COMPLETE_ARRANGE',
      TYPE: 'TYPE',
      GROUPING: 'GROUPING',
      TABLE_FILL: 'TABLE_FILL',
      GRAPH: 'GRAPH',
      STATIC: 'STATIC',
      POLL: 'POLL',
      HARD_SKILL: 'HARD_SKILL',
      SEMI_HARD_SKILL: 'SEMI_HARD_SKILL',
      MULTIPLE_CHOICE_WITH_IMAGE: 'MULTIPLE_CHOICE_WITH_IMAGE'
    };

    // Initialize when KaTeX is ready
    document.addEventListener('DOMContentLoaded', () => {
      // Listen for postMessage from LangSmith
      window.addEventListener('message', handleMessage);

      // Also check for data passed via URL params (for testing)
      const urlParams = new URLSearchParams(window.location.search);
      const testData = urlParams.get('testData');
      if (testData) {
        try {
          const parsed = JSON.parse(decodeURIComponent(testData));
          handleMessage({ data: parsed });
        } catch (e) {
          console.error('Failed to parse test data:', e);
        }
      }
    });

    /**
     * Handle incoming postMessage events from LangSmith
     */
    function handleMessage(event) {
      // LangSmith sends data in this format:
      // { type: "output" | "reference", data: [...], metadata: { inputs: {...} } }
      const message = event.data;

      // Validate message structure
      if (!message || typeof message !== 'object') {
        return;
      }

      // Check if this looks like LangSmith data
      if (!message.data && !message.type) {
        return;
      }

      currentData = message;
      renderExercises(message);
    }

    /**
     * Main render function
     */
    function renderExercises(message) {
      const app = document.getElementById('app');

      try {
        // Normalize data to always be an array
        let exercises = message.data;
        if (!exercises) {
          app.innerHTML = renderEmptyState('No exercise data received');
          return;
        }

        // Handle single exercise object
        if (!Array.isArray(exercises)) {
          exercises = [exercises];
        }

        // Filter out null/undefined entries
        exercises = exercises.filter(e => e != null);

        if (exercises.length === 0) {
          app.innerHTML = renderEmptyState('Exercise array is empty');
          return;
        }

        // Build HTML
        let html = '';

        // Data type indicator
        if (message.type) {
          html += `<div class="data-type-indicator ${message.type}">
            ${message.type === 'output' ? '&#x1F4E4;' : '&#x1F4CB;'}
            ${message.type === 'output' ? 'Model Output' : 'Reference Data'}
          </div>`;
        }

        // Metadata section (if available)
        if (message.metadata && message.metadata.inputs) {
          html += renderMetadata(message.metadata.inputs);
        }

        // Exercises container
        html += '<div class="exercises-container">';

        exercises.forEach((exercise, index) => {
          html += renderExercise(exercise, index, exercises.length);
        });

        html += '</div>';

        // Debug section
        html += renderDebugSection(message);

        app.innerHTML = html;

        // Setup debug toggle
        setupDebugToggle();

      } catch (error) {
        app.innerHTML = renderErrorState(error);
      }
    }

    /**
     * Render a single exercise based on its type
     */
    function renderExercise(exercise, index, total) {
      const exerciseType = exercise.exerciseType || 'UNKNOWN';
      const content = exercise.content || '';

      let html = `<div class="exercise">`;

      // Header with type badge
      const badgeClass = getTypeBadgeClass(exerciseType);
      html += `<div class="exercise-header">
        <span class="exercise-type-badge ${badgeClass}">${formatExerciseType(exerciseType)}</span>
        ${total > 1 ? `<span class="exercise-number">Exercise ${index + 1} of ${total}</span>` : ''}
      </div>`;

      // Content (with card handling)
      html += renderContent(content);

      // Render based on exercise type
      switch (exerciseType) {
        case EXERCISE_TYPES.MULTIPLE_CHOICE:
        case EXERCISE_TYPES.MULTIPLE_CHOICE_WITH_IMAGE:
        case EXERCISE_TYPES.POLL:
          html += renderMultipleChoice(exercise);
          break;
        case EXERCISE_TYPES.MULTI_SELECT:
          html += renderMultiSelect(exercise);
          break;
        case EXERCISE_TYPES.TRUE_OR_FALSE:
          html += renderTrueOrFalse(exercise);
          break;
        case EXERCISE_TYPES.MATCH:
        case EXERCISE_TYPES.MATCH_WITH_IMAGE:
          html += renderMatch(exercise);
          break;
        case EXERCISE_TYPES.ARRANGE:
        case EXERCISE_TYPES.COMPLETE_ARRANGE:
          html += renderArrange(exercise);
          break;
        case EXERCISE_TYPES.TYPE:
        case EXERCISE_TYPES.HARD_SKILL:
        case EXERCISE_TYPES.SEMI_HARD_SKILL:
          html += renderType(exercise);
          break;
        case EXERCISE_TYPES.GROUPING:
          html += renderGrouping(exercise);
          break;
        case EXERCISE_TYPES.TABLE_FILL:
          html += renderTableFill(exercise);
          break;
        case EXERCISE_TYPES.GRAPH:
          html += renderGraph(exercise);
          break;
        case EXERCISE_TYPES.STATIC:
          // Static exercises just show content, no interaction
          break;
        default:
          // Fallback to choices if available
          if (exercise.choices && exercise.choices.length > 0) {
            html += renderMultipleChoice(exercise);
          }
      }

      html += '</div>';

      return html;
    }

    /**
     * Get badge CSS class for exercise type
     */
    function getTypeBadgeClass(type) {
      switch (type) {
        case EXERCISE_TYPES.MULTI_SELECT:
          return 'multi-select';
        case EXERCISE_TYPES.MATCH:
        case EXERCISE_TYPES.MATCH_WITH_IMAGE:
          return 'match';
        case EXERCISE_TYPES.TRUE_OR_FALSE:
          return 'true-false';
        case EXERCISE_TYPES.ARRANGE:
        case EXERCISE_TYPES.COMPLETE_ARRANGE:
          return 'arrange';
        case EXERCISE_TYPES.TYPE:
        case EXERCISE_TYPES.HARD_SKILL:
        case EXERCISE_TYPES.SEMI_HARD_SKILL:
          return 'type';
        case EXERCISE_TYPES.GROUPING:
          return 'grouping';
        case EXERCISE_TYPES.TABLE_FILL:
          return 'table';
        default:
          return '';
      }
    }

    /**
     * Render MULTIPLE_CHOICE exercise
     */
    function renderMultipleChoice(exercise) {
      const choices = exercise.choices || [];
      if (choices.length === 0) return '';

      let html = '<div class="choices-container">';

      choices.forEach((choice, index) => {
        const isCorrect = index === 0; // First choice is always correct
        const letter = String.fromCharCode(65 + index);

        html += `<div class="choice-button ${isCorrect ? 'correct' : ''}">
          <span class="choice-indicator">${isCorrect ? '&#x2713;' : letter}</span>
          <span class="choice-content">${formatMathContent(choice)}</span>
          ${isCorrect ? '<span class="correct-icon">&#x2713;</span>' : ''}
        </div>`;
      });

      html += '</div>';
      return html;
    }

    /**
     * Render MULTI_SELECT exercise (multiple correct answers)
     */
    function renderMultiSelect(exercise) {
      const choices = exercise.choices || [];
      const correctAnswers = exercise.correctAnswers || [];
      if (choices.length === 0) return '';

      let html = '<div class="choices-container">';

      choices.forEach((choice, index) => {
        // Check if this choice is a correct answer
        const isCorrect = correctAnswers.includes(choice) || index < correctAnswers.length;

        html += `<div class="choice-button ${isCorrect ? 'correct' : ''}">
          <span class="choice-checkbox">${isCorrect ? '&#x2713;' : ''}</span>
          <span class="choice-content">${formatMathContent(choice)}</span>
          ${isCorrect ? '<span class="correct-icon">&#x2713;</span>' : ''}
        </div>`;
      });

      html += '</div>';
      return html;
    }

    /**
     * Render TRUE_OR_FALSE exercise
     */
    function renderTrueOrFalse(exercise) {
      const correctAnswer = exercise.correctAnswer || exercise.choices?.[0] || 'True';
      const isTrue = correctAnswer.toLowerCase() === 'true';

      let html = '<div class="choices-container layout-row" style="gap: 16px;">';

      html += `<div class="choice-button ${isTrue ? 'correct' : ''}" style="flex: 1; justify-content: center;">
        <span class="choice-indicator">${isTrue ? '&#x2713;' : ''}</span>
        <span class="choice-content">True</span>
      </div>`;

      html += `<div class="choice-button ${!isTrue ? 'correct' : ''}" style="flex: 1; justify-content: center;">
        <span class="choice-indicator">${!isTrue ? '&#x2713;' : ''}</span>
        <span class="choice-content">False</span>
      </div>`;

      html += '</div>';
      return html;
    }

    /**
     * Render MATCH exercise (matching pairs)
     */
    function renderMatch(exercise) {
      const matches = exercise.matches || [];
      if (matches.length === 0) return '';

      let html = '<div class="match-container">';

      matches.forEach((match, index) => {
        const left = match.l || match.left || '';
        const right = match.r || match.right || '';

        html += `<div class="match-pair">
          <div class="match-item">${formatMathContent(left)}</div>
          <span class="match-arrow">&#x2194;</span>
          <div class="match-item">${formatMathContent(right)}</div>
        </div>`;
      });

      html += '</div>';
      return html;
    }

    /**
     * Render ARRANGE exercise (ordered list - order matters)
     */
    function renderArrange(exercise) {
      const items = exercise.arrangeItems || exercise.choices || [];
      const isCompleteArrange = exercise.exerciseType === EXERCISE_TYPES.COMPLETE_ARRANGE;
      const ignoreOrder = exercise.ignoreOrder || isCompleteArrange;

      if (items.length === 0) return '';

      let html = '<div class="arrange-container">';

      // For COMPLETE_ARRANGE, show items as filled blanks (order doesn't matter)
      // For ARRANGE, show numbered sequence (order matters)
      items.forEach((item, index) => {
        const content = typeof item === 'object' ? item.choice || item.text : item;

        if (ignoreOrder) {
          // Complete Arrange: show as filled blanks without numbers
          html += `<div class="arrange-item complete-arrange">
            <span class="arrange-blank-indicator">&#x2713;</span>
            <span class="arrange-content">${formatMathContent(content)}</span>
          </div>`;
        } else {
          // Regular Arrange: show numbered sequence
          html += `<div class="arrange-item">
            <span class="arrange-number">${index + 1}</span>
            <span class="arrange-content">${formatMathContent(content)}</span>
          </div>`;
        }
      });

      html += '</div>';
      return html;
    }

    /**
     * Render TYPE exercise (fill-in-blank / free input)
     */
    function renderType(exercise) {
      const correctAnswers = exercise.correctAnswers || exercise.answers || [];
      if (correctAnswers.length === 0 && !exercise.answer) return '';

      let html = '<div class="input-container">';

      if (exercise.answer) {
        html += `<div class="input-field">
          <span class="input-label">Answer:</span>
          <div class="input-answer">${formatMathContent(exercise.answer)}</div>
        </div>`;
      } else {
        correctAnswers.forEach((answer, index) => {
          const label = correctAnswers.length > 1 ? `Answer ${index + 1}:` : 'Answer:';
          html += `<div class="input-field">
            <span class="input-label">${label}</span>
            <div class="input-answer">${formatMathContent(answer)}</div>
          </div>`;
        });
      }

      html += '</div>';
      return html;
    }

    /**
     * Render GROUPING exercise (categorization)
     */
    function renderGrouping(exercise) {
      const left = exercise.left || exercise.groupA || [];
      const right = exercise.right || exercise.groupB || [];
      const leftLabel = exercise.leftLabel || 'Group A';
      const rightLabel = exercise.rightLabel || 'Group B';

      if (left.length === 0 && right.length === 0) return '';

      let html = '<div class="grouping-container">';

      // Left column
      html += '<div class="grouping-column">';
      html += `<div class="grouping-header left">${escapeHtml(leftLabel)}</div>`;
      left.forEach(item => {
        html += `<div class="grouping-item left">${formatMathContent(item)}</div>`;
      });
      html += '</div>';

      // Right column
      html += '<div class="grouping-column">';
      html += `<div class="grouping-header right">${escapeHtml(rightLabel)}</div>`;
      right.forEach(item => {
        html += `<div class="grouping-item right">${formatMathContent(item)}</div>`;
      });
      html += '</div>';

      html += '</div>';
      return html;
    }

    /**
     * Render TABLE_FILL exercise
     */
    function renderTableFill(exercise) {
      const headers = exercise.headers || [];
      const rows = exercise.rows || [];
      const answers = exercise.answers || {};

      if (headers.length === 0 && rows.length === 0) return '';

      let html = '<div class="table-container"><table class="exercise-table">';

      // Headers
      if (headers.length > 0) {
        html += '<thead><tr>';
        headers.forEach(header => {
          html += `<th>${formatMathContent(header)}</th>`;
        });
        html += '</tr></thead>';
      }

      // Rows
      if (rows.length > 0) {
        html += '<tbody>';
        rows.forEach((row, rowIndex) => {
          html += '<tr>';
          row.forEach((cell, cellIndex) => {
            const isAnswer = answers[`${rowIndex}-${cellIndex}`] !== undefined;
            const cellContent = isAnswer ? answers[`${rowIndex}-${cellIndex}`] : cell;
            html += `<td class="${isAnswer ? 'answer' : ''}">${formatMathContent(cellContent)}</td>`;
          });
          html += '</tr>';
        });
        html += '</tbody>';
      }

      html += '</table></div>';
      return html;
    }

    /**
     * Render GRAPH exercise (placeholder - graphs are complex)
     */
    function renderGraph(exercise) {
      const graphType = exercise.graphType || exercise.graphConfig?.graphType || 'unknown';

      return `<div style="padding: 24px; background: var(--tertiary-50); border-radius: 12px; text-align: center; color: #6B7280;">
        <div style="font-size: 32px; margin-bottom: 8px;">&#x1F4CA;</div>
        <div style="font-size: 14px;">Graph Exercise: <strong>${formatExerciseType(graphType)}</strong></div>
        <div style="font-size: 12px; margin-top: 4px;">Graph rendering requires native implementation</div>
      </div>`;
    }

    /**
     * Render exercise content with [card] tag support
     */
    function renderContent(content) {
      if (!content) return '';

      // Parse [card] tags
      const blocks = parseCardTags(content);

      let html = '';

      blocks.forEach(block => {
        if (block.type === 'card') {
          const alignClass = block.align ? `align-${block.align}` : 'align-center';
          const justifyClass = block.justify ? `justify-${block.justify}` : '';
          html += `<div class="card-section ${alignClass} ${justifyClass}">
            <div class="exercise-content">${formatMathContent(block.value)}</div>
          </div>`;
        } else {
          const formatted = formatMathContent(block.value);
          if (formatted.trim()) {
            html += `<div class="exercise-content">${formatted}</div>`;
          }
        }
      });

      return html;
    }

    /**
     * Parse [card] tags from content
     */
    function parseCardTags(content) {
      const blocks = [];
      let currentIndex = 0;

      while (currentIndex < content.length) {
        // Find next [card] tag
        const cardStartMatch = content.substring(currentIndex).match(/\[card[^\]]*\]/i);

        if (!cardStartMatch) {
          // No more cards, add remaining text
          const remaining = content.substring(currentIndex).trim();
          if (remaining) {
            blocks.push({ type: 'text', value: remaining });
          }
          break;
        }

        const cardStartIndex = currentIndex + cardStartMatch.index;
        const cardContentStart = cardStartIndex + cardStartMatch[0].length;

        // Parse align and justify from tag
        const fullTag = cardStartMatch[0];
        let align, justify;

        const alignMatch = fullTag.match(/align=(center|start|end)/i);
        if (alignMatch) align = alignMatch[1].toLowerCase();

        const justifyMatch = fullTag.match(/justify=(center|start|end)/i);
        if (justifyMatch) justify = justifyMatch[1].toLowerCase();

        // Find closing tag
        const cardEndMatch = content.substring(cardContentStart).match(/\[\/card\]/i);

        if (!cardEndMatch) {
          // No closing tag, treat rest as text
          const remaining = content.substring(currentIndex).trim();
          if (remaining) {
            blocks.push({ type: 'text', value: remaining });
          }
          break;
        }

        const cardEndIndex = cardContentStart + cardEndMatch.index;
        const cardContentEnd = cardEndIndex + cardEndMatch[0].length;

        // Add text before card
        const textBefore = content.substring(currentIndex, cardStartIndex).trim();
        if (textBefore) {
          blocks.push({ type: 'text', value: textBefore });
        }

        // Add card content
        const cardContent = content.substring(cardContentStart, cardEndIndex).trim();
        if (cardContent) {
          blocks.push({
            type: 'card',
            value: cardContent,
            align,
            justify
          });
        }

        currentIndex = cardContentEnd;
      }

      return blocks;
    }

    /**
     * Format content for math rendering
     * Renders LaTeX inline using KaTeX
     */
    function formatMathContent(content) {
      if (!content) return '';

      // Handle arrays (sometimes content comes as array of objects)
      if (Array.isArray(content)) {
        return content.map(item => {
          if (typeof item === 'string') return formatMathContent(item);
          if (item.type === 'latex') return formatMathContent(item.content);
          if (item.type === 'text') return escapeHtml(item.content);
          return '';
        }).join('');
      }

      // Check if KaTeX is available
      if (typeof katex === 'undefined') {
        console.error('KaTeX not loaded!');
        return escapeHtmlLight(content).replace(/\n/g, '<br>');
      }

      // Use regex to find and replace math expressions
      let result = content;

      // First handle display math $$...$$
      result = result.replace(/\$\$([^$]+)\$\$/g, (match, math) => {
        try {
          return katex.renderToString(math, { displayMode: true, throwOnError: false });
        } catch (e) {
          console.warn('KaTeX display error:', e, math);
          return match;
        }
      });

      // Then handle inline math $...$
      result = result.replace(/\$([^$]+)\$/g, (match, math) => {
        try {
          return katex.renderToString(math, { displayMode: false, throwOnError: false });
        } catch (e) {
          console.warn('KaTeX inline error:', e, math);
          return match;
        }
      });

      // Handle [[blank]] markers (fill-in-blank answers)
      result = result.replace(/\[\[([^\]]+)\]\]/g, (match, answer) => {
        return `<span class="blank-answer">${formatMathContent(answer)}</span>`;
      });

      // Handle newlines and escape HTML in non-math parts
      result = result.replace(/\n/g, '<br>');

      return result;
    }

    function escapeHtmlLight(text) {
      return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    /**
     * Escape HTML special characters (for non-math content like metadata)
     */
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    /**
     * Render metadata section
     */
    function renderMetadata(inputs) {
      const entries = Object.entries(inputs);
      if (entries.length === 0) return '';

      let html = '<div class="metadata-section"><h4>Input Parameters</h4>';

      entries.forEach(([key, value]) => {
        const displayValue = typeof value === 'object'
          ? JSON.stringify(value, null, 2).substring(0, 100) + '...'
          : String(value).substring(0, 100);

        html += `<div class="metadata-item">
          <span class="metadata-label">${escapeHtml(key)}:</span>
          <span class="metadata-value">${escapeHtml(displayValue)}</span>
        </div>`;
      });

      html += '</div>';
      return html;
    }

    /**
     * Render debug section
     */
    function renderDebugSection(data) {
      return `<div class="debug-section">
        <button class="debug-toggle" onclick="toggleDebug()">
          <span class="arrow">&#x25B6;</span>
          Show Raw JSON
        </button>
        <div class="debug-content" id="debugContent">
          <pre>${escapeHtml(JSON.stringify(data, null, 2))}</pre>
        </div>
      </div>`;
    }

    /**
     * Toggle debug section visibility
     */
    function toggleDebug() {
      debugVisible = !debugVisible;
      const content = document.getElementById('debugContent');
      const toggle = document.querySelector('.debug-toggle');

      if (debugVisible) {
        content.classList.add('visible');
        toggle.classList.add('expanded');
        toggle.innerHTML = '<span class="arrow">&#x25B6;</span> Hide Raw JSON';
      } else {
        content.classList.remove('visible');
        toggle.classList.remove('expanded');
        toggle.innerHTML = '<span class="arrow">&#x25B6;</span> Show Raw JSON';
      }
    }

    /**
     * Setup debug toggle event listener
     */
    function setupDebugToggle() {
      // Event listener is attached via onclick in the HTML
    }

    /**
     * Render empty state
     */
    function renderEmptyState(message) {
      return `<div class="empty-state">
        <h3>No Exercises to Display</h3>
        <p>${escapeHtml(message)}</p>
      </div>`;
    }

    /**
     * Render error state
     */
    function renderErrorState(error) {
      return `<div class="error-state">
        <h3>Error Rendering Exercises</h3>
        <p>${escapeHtml(error.message || 'Unknown error occurred')}</p>
        <pre style="margin-top: 12px; font-size: 11px; opacity: 0.8;">${escapeHtml(error.stack || '')}</pre>
      </div>`;
    }

    /**
     * Format exercise type for display
     */
    function formatExerciseType(type) {
      if (!type) return 'Exercise';

      // Convert MULTIPLE_CHOICE to "Multiple Choice"
      return type
        .replace(/_/g, ' ')
        .toLowerCase()
        .replace(/\b\w/g, c => c.toUpperCase());
    }

    // Expose functions for testing
    window.aikea = {
      renderExercises,
      handleMessage,
      parseCardTags,
      formatMathContent
    };

    // Demo data for testing - can be triggered via URL param ?demo=true
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('demo') === 'true') {
      setTimeout(() => {
        handleMessage({
          data: {
            type: 'output',
            data: [
              // MULTIPLE_CHOICE
              {
                content: "[card]$\\left(\\frac{b^5}{b^?}\\right)^2=b^4$[/card]\nWhich value for $?$ makes the statement true?",
                choices: ["$2$", "$3$", "$4$", "$5$"],
                exerciseType: "MULTIPLE_CHOICE"
              },
              // MULTI_SELECT
              {
                content: "Select all expressions that are equivalent to $8x + 12$",
                choices: ["$4(2x + 3)$", "$2(4x + 6)$", "$8(x + 4)$", "$4(2x + 4)$"],
                correctAnswers: ["$4(2x + 3)$", "$2(4x + 6)$"],
                exerciseType: "MULTI_SELECT"
              },
              // TRUE_OR_FALSE
              {
                content: "The square root of 144 is 12.",
                correctAnswer: "True",
                exerciseType: "TRUE_OR_FALSE"
              },
              // MATCH
              {
                content: "Match each expression with its simplified form.",
                matches: [
                  { l: "$2^3$", r: "$8$" },
                  { l: "$3^2$", r: "$9$" },
                  { l: "$5^2$", r: "$25$" },
                  { l: "$4^2$", r: "$16$" }
                ],
                exerciseType: "MATCH"
              },
              // ARRANGE (order matters)
              {
                content: "Arrange the following steps to solve $2x + 5 = 13$",
                choices: [
                  "Subtract 5 from both sides",
                  "Get $2x = 8$",
                  "Divide both sides by 2",
                  "Get $x = 4$"
                ],
                exerciseType: "ARRANGE"
              },
              // COMPLETE_ARRANGE (order doesn't matter - fill in blanks)
              {
                content: "Fill in the blanks to complete the equation: $\\frac{?}{4} + \\frac{?}{4} = \\frac{5}{4}$",
                choices: ["$2$", "$3$"],
                ignoreOrder: true,
                exerciseType: "COMPLETE_ARRANGE"
              },
              // TYPE
              {
                content: "Solve for $x$: $3x - 7 = 14$",
                answer: "$x = 7$",
                exerciseType: "TYPE"
              },
              // GROUPING
              {
                content: "Sort the following into rational and irrational numbers.",
                left: ["$\\frac{1}{2}$", "$0.75$", "$-3$"],
                right: ["$\\sqrt{2}$", "$\\pi$", "$\\sqrt{5}$"],
                leftLabel: "Rational",
                rightLabel: "Irrational",
                exerciseType: "GROUPING"
              },
              // TABLE_FILL
              {
                content: "Complete the table for $y = 2x + 1$",
                headers: ["$x$", "$y$"],
                rows: [
                  ["$0$", "$1$"],
                  ["$1$", "$3$"],
                  ["$2$", "$5$"],
                  ["$3$", "$7$"]
                ],
                exerciseType: "TABLE_FILL"
              }
            ],
            metadata: {
              inputs: {
                topic: "Algebra & Number Properties",
                difficulty: "medium",
                grade: "8th"
              }
            }
          }
        });
      }, 300);
    }
  </script>
</body>
</html>
